@icon("res://shared/icons/footstep.png")
extends AudioStreamPlayer3D

# See also CBasePlayer::SetStepSoundTime, UpdateStepSound.

const BASE_VOLUME := 0.5
const JUMP_VOLUME := 1.0

const SURFACE_MAP := {
	"default": preload("res://sfx/common/footstep/concrete.tres"),
	"concrete": preload("res://sfx/common/footstep/concrete.tres"),
	"dirt": preload("res://sfx/common/footstep/dirt.tres"),
	"grass": preload("res://sfx/common/footstep/grass.tres"),
	"flesh": preload("res://sfx/common/impact_bullet/flesh_impact_bullet.tres"),
	"metal": preload("res://sfx/common/footstep/metal.tres"),
}

@onready var player: Player = owner
@onready var step_timer: Timer = $Step

func _physics_process(_delta) -> void:
	if player.just_jumped:
		play_for_surface(JUMP_VOLUME)
	
	if not step_timer.is_stopped():
		return
	
	if (player.grounded	and is_moving_fast_enough()):
		# See CBasePlayer::SetStepSoundTime.
		# Arbitrary durations for now, as they're seemingly tied to the animations.
		step_timer.start(0.5 if player.crouched else 0.45)
		
		play_for_surface(get_footstep_volume())
	


func play_for_surface(volume: float):
	# HACK: Find a floor to further down than reasonable.
	# The footsteps can only ever happen when grounded, anyway.
	var feet_collision := player.move_and_collide(Vector3.DOWN * 10, true)
	assert(feet_collision)
	
	var surface_type := get_surface_type(feet_collision.get_collider(0))
	stream = SURFACE_MAP.get(surface_type, preload("res://sfx/common/crit_hit1.ogg"))
	
	volume_linear = volume
	global_position = player.global_position
	play()

func is_walking() -> bool:
	# Based on thorough testing. Yeah.
	var threshold := player.get_max_speed() * (0.9 if player.crouched else 0.8)
	
	if player.velocity.length_squared() >= threshold * threshold:
		return false
	
	return true

func get_footstep_volume():
	# This and BASE_VOLUME should depend on the surface but I can't be bothered right now.
	var volume := BASE_VOLUME
	var multiplier := 1.0
	if player.crouched:
		multiplier *= 0.65
	
	if is_walking():
		multiplier *= 0.4
	
	return volume * multiplier

func is_moving_fast_enough() -> bool:
	# Not actually based on CBasePlayer::GetStepSoundVelocities.
	var required_speed := player.get_max_speed() * (0.75 if player.crouched else 0.3)
	
	return player.velocity.length_squared() >= required_speed * required_speed


static func get_surface_type(node: Node3D) -> String:
	if not node:
		return ""
	
	if node is Player:
		return "flesh"
	
	# Should probably rely on metadata but this is good for autogenerated VMF surfaces.
	if node.name.begins_with("surface_prop_"):
		return node.name.trim_prefix("surface_prop_")
	
	return "default"
	
	
